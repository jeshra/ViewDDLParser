import net.sf.jsqlparser.JSQLParserException;
import net.sf.jsqlparser.expression.Function;
import net.sf.jsqlparser.expression.operators.relational.Between;
import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
import net.sf.jsqlparser.parser.CCJSqlParserUtil;
import net.sf.jsqlparser.schema.Table;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.Statements;
import net.sf.jsqlparser.statement.create.view.CreateView;
import net.sf.jsqlparser.statement.select.SelectBody;
import net.sf.jsqlparser.statement.select.TableFunction;
import net.sf.jsqlparser.util.TablesNamesFinder;

import java.util.*;

public class ParseFunction {
    private static List<String> linkedNames = new ArrayList<>();
    private static Map<String, List<String>> stringListTreeMapTables = new TreeMap<>();
    private static List<String> LineageCreateTableList = new ArrayList<>();
    private static List<String> NonLineageCreateTableList = new ArrayList<>();
    //System.out.println("NonLineageCreateTableList->" + NonLineageCreateTableList.toString());

    public static void main(String[] args) throws JSQLParserException {
        basicMain();

    }


    private static void basicMain() throws JSQLParserException {
        Statements statements;
        String sqlFile = "src/main/resources/SampleSQL.txt";
        String test;
        test = SQLFileReader.fileToString(sqlFile).toLowerCase();
        statements = CCJSqlParserUtil.parseStatements(test);
        int i = 0;
        for (Statement statement : statements.getStatements()) {
            findTableFromView(i, statement);
            i = i + 1;
        }

        System.out.println("stringListTreeMapTables.toString():" + stringListTreeMapTables.toString());
        NonLineageCreateTableList.addAll(stringListTreeMapTables.keySet());
        //processLineage(stringListTreeMapTables);
        for (String Table : NonLineageCreateTableList)
            processLineage2(Table, stringListTreeMapTables);
        System.out.println("LineageCreateTableList->" + LineageCreateTableList.toString());
        linkedNames.toString();
    }

    private static void findTableFromView(int iteration, Statement statement) throws JSQLParserException {
        CreateView createView = (CreateView) statement;
        TablesNamesFinderExt tablesNamesFinder = new TablesNamesFinderExt();
        SelectBody select = createView.getSelectBody();//.getSelect();
        Statement s1 = CCJSqlParserUtil.parse(select.toString());
        stringListTreeMapTables.put(createView.getView().getName(), tablesNamesFinder.getTableList(s1));
    }


    static int i = 0;

    private static void processLineage2(String Table, Map<String, List<String>> tableMap) {
        /*if (i == 0) {
            LineageCreateTableList.add(Table);
        }*/
        //System.out.println("NonLineageCreateTableList.toString():" + NonLineageCreateTableList.toString());
        System.out.println("Table:" + Table);
        if ((NonLineageCreateTableList.indexOf(Table)) != -1) {
            System.out.println("Table inside if:" + Table);
            List<String> baseTableList = tableMap.get(Table);
            System.out.println("List<String> baseTableList: " + baseTableList);
            for (String baseTable : baseTableList) {
                processLineage2(baseTable, tableMap);
            }
        }
        /*if ((NonLineageCreateTableList.indexOf(Table)) != -1) {

        }

        for (Map.Entry<String, List<String>> ee : tableMap.entrySet()) {
            String key = ee.getKey();
            List<String> values = ee.getValue();
            for (String baseTable : values) {
                processLineage2(key, baseTable);


            }
        }*/
    }

    private static void processLineage(Map<String, List<String>> tableMap) {
        List<String> NonLineageCreateTableList = new ArrayList<>(tableMap.keySet());
        System.out.println("NonLineageCreateTableList->" + NonLineageCreateTableList.toString());
        int i = 0;
/*        for (Entry<String, List<Integer>> ee : map.entrySet()) {
            String key = ee.getKey();
            List<Integer> values = ee.getValue();
        }*/
        String createViewTableName;
        for (String f_viewName : tableMap.keySet()) {
            createViewTableName = f_viewName;
            if (i == 0) {
                LineageCreateTableList.add(f_viewName);
            } else if (LineageCreateTableList.indexOf(createViewTableName) == -1)
                LineageCreateTableList.add(createViewTableName);
            System.out.println(">>>LineageCreateTableList.toString()->" + LineageCreateTableList.toString());


            List<String> baseTableList = tableMap.get(f_viewName);
            System.out.println("tableMap.get(" + f_viewName + ")->" + baseTableList.toString());
            int ind;
            for (String baseTable : baseTableList) {
                System.out.println("forLoop of baseTable: " + baseTable);
                if ((ind = NonLineageCreateTableList.indexOf(baseTable)) != -1) {
                    int createViewIndex;
                    System.out.println("BBEFORE LineageCreateTableList add:" + LineageCreateTableList.toString());
                    if (LineageCreateTableList.indexOf(baseTable) == -1)
                        LineageCreateTableList.add(baseTable);


                    createViewIndex = LineageCreateTableList.indexOf(f_viewName);
                    System.out.println("AAFTER LineageCreateTableList add:" + LineageCreateTableList.toString());
                    //TODO: recursive function call as like in Scala
                    int baseTableIndex = LineageCreateTableList.indexOf(baseTable);
                    System.out.println("ind->" + ind + ", createViewIndex->" + createViewIndex + ", baseTableIndex" +
                            "->" + baseTableIndex);
                    System.out.println("BEFORE swap of linkedNames (" + i + ")->" + LineageCreateTableList.toString());
                    // if first time, no need to check in orderFixedTableList
                    if (i == 0) {
                        Collections.swap(LineageCreateTableList, createViewIndex, baseTableIndex);
                        //orderFixedTableList.addAll(LineageCreateTableList);
                    } else {
                        // if not first time, check orderFixedTableList, already in sorted/swaped or not.

                        if (LineageCreateTableList.indexOf(f_viewName) < LineageCreateTableList.indexOf(baseTable)) {
                            Collections.swap(LineageCreateTableList, createViewIndex, baseTableIndex);
                        }
                    }

                    System.out.println("AFTER swap of linkedNames (" + i + ")->" + LineageCreateTableList.toString());
                }
            }
            //}
            System.out.println("\n");
            i = i + 1;
        }
    }

    static class TablesNamesFinderExt extends TablesNamesFinder {
        //            @Override
//            public void visit(Column tableColumn) {
//                System.out.println("column = " + tableColumn);
//            }

        @Override
        public void visit(Function function) {
            ExpressionList exprList = function.getParameters();
            if (exprList != null) {
                visit(exprList);
            }
            //System.out.println("function = " + function.getName());
            super.visit(function);
        }


        @Override
        public void visit(Table tableName) {
            //System.out.println("BaseTable:\t" + tableName.getFullyQualifiedName());
            //System.out.println("table getDatabase = " + tableName.getSchemaName());
            //System.out.println(statement.);
            super.visit(tableName);
        }

        @Override
        public void visit(TableFunction valuesList) {
            System.out.println("table function = " + valuesList.getFunction().getName());
            super.visit(valuesList);
        }


        @Override
        public void visit(Between between) {
            System.out.println("Boolean start:" + between.getBetweenExpressionStart());

            System.out.println("Boolean end:" + between.getBetweenExpressionEnd());
            System.out.println("Boolean getLeftExpression:" + between.getLeftExpression());
            super.visit(between);
        }
    }

}
